import { Injectable } from '@angular/core';
import { Router } from '@angular/router';

export interface PostObject {
	id: number;
	title: string;
	author: string;
	date: string;
	bodyTag: string;
	body: string;
	type: number; // 0 - Featured, 1 - Other, 2 - News
	image: string[];
	imageLink: string;
}

@Injectable({
	providedIn: 'root'
})
export class SfPostService {

	constructor(private router: Router) { }

	posts: PostObject[] = [
		{ id: 0, title: 'MSPI 1-Byte Minecraft Processor', author: 'Sohail', date: '1-28-2021 - 1:58pm', bodyTag: "Summary", body: "<p>This was a project for Computer Architecture. I designed my own 1 byte processor architecture and implemented it in Minecraft. The premise was that learning the cycles of a processor might be less abstract if a student could watch the cycles take place and interact with it. </p> <p> The project was a success in that I was actually able to program a simple script in redstone that the processor could read and execute. My professor (Dr.Apan Qasem) offered me the opportunity to develop the idea.You can see the result of that work<a href = 'https://youtu.be/SobCXfsHwbo'> here</a>. I also did a breakdown of the elements, which you can see <a href = 'https://youtu.be/FSZAUTlHAMk'>here</a>. Ultimately, the limitations of the minecraft lighting engine made the game quite laggy, so introducing more complexity did not seem feasible at the time. </p> <p> Since then, Minecraft has released a new version of Minecraft that doesn't use Java RTE, and is thus somewhat faster at render times. The MSPI map file is completely incompatable, however, and several of the redstone mechanisms no longer work after updates to how redstone works. I'm not sure I'll ever be able to pick this one up again but it was a fun an interesting project. </p><h3>Features</h3><p>The MSPI processor - which stands for Many Seconds Per an Instruction - could perform the following operations:<ul><li>Addition</li><li>Reverse Addition</li><li>Add Immediate</li><li>Register Move</li><li>Write to Memory</li><li>Read from Memory</li><li>Jump if Not Equal</li><li>Play Chime</li></ul></p><p>That last one was simply an auditory cue to indicate that the end of the script had been successfully reached. With 8 operations, the processor needed 3 bits to specify which operation was being invoked, which allowed 5 bits for the operand. Sadly, the only instructions that could make use of all 8 bits were ADDI and JNE due to the fact that implementing register and memory hardware was extremely time consuming. There was also the fact that, with 5 bits we could have 32 registers and 32 memory locations that are functionally indestinguishable, since they are implemented identically in Minecraft, and thust fail to demonstrate to the audience that there is an important difference between them.</p>List of hardware features:<ul><li>Up to 32 lines of instruction memory</li><li>4 registers, including a zero register</li><li>8 memory locations</li><li>A 1-byte ALU</li><li>A 5-bit Program Counter (for 32 instructions)</li></ul><h3>Important Design Changes from a Classic MIPS Processor</h3><p>The first most obvious design change was that the user needed to engage certain checkpoints in the processor. For instance, during an ADD instruction, the user would have to 'release' the bits from the register to the ALU, or from the MEM to REG. This was partly by design, because the goal of the project was to create a virtual teaching environment and having the user participate seemed like a good way to have them engage with the processor. It was also just incredibly difficult to try and automate. It was a goal but my team and I never made it.</p><p>The second difference is that that, since the Program Counter needs to use the ALU to update its count, each operation occurs in 2 stage. In the first stage, the operation is performed, and in the second, the PC releases its bits to the ALU which then adds 1 and dumps the result back into the PC for the next cycle.</p><p>The register file was also built to need as few operands as possible, and the fourth register serves as the input/output register. For instance, the ADD operation doesn't need any operands, because it always takes the values in registers 1 and 2 and puts the result in 3. In Mem read the result goes to 3 and in Mem write the data comes from 3</p><p>The last major distinction is in how the processor operates was that there is absolutely -no pipelining- in MSPI. The notion is kind of making me go cross-eyed and implementing it, while not impossible, probably defeates the purpose of having a processor that a user could potentially follow along with during a cycle of operations.</p><h3>Major Challenges</h3><p>The greatest challenge in this project was not designing my own computer architecture but the time it took trying to implement it. I may have easily put over 100 hours into this project simply putting down blocks and redstone. If I had started with a clear idea of what the processor was to look like, with blueprints for instance, it would still take me an outrageous amount of time, because that is the nature of building something one atom at a time</p><p>In addition, redstone, because of certain artifacts of Minecraft, is not as predictable as I had expected when I started out, and so several hours of implementing went to chasing my tail looking for gremlins.</p><p>Redstone was also difficult to work with because it was <b>slow</b>. The signals traveling from one component to another moved like sludge through a staw. This was kind of to our benefit since the user could easily trace which direction bits were traveling, but it also created many complications and timing issues. In truth, one of the reasons the user is <i>required</i> to release bits in the different sections is because it was a way to synchronize the difference in the bits' arrival times, and several Rube Goldberg style contraptions had to be implemented in the areas that were automated in order to work around the timing issues.</p><p>The major design challenges I faced had mostly to do with working around Minecraft's idiosyncrasies. In the face of all the inconsistencies I had to create work-arounds for, there really wasn't anything significantly challenging about designing this architecture.</p><h3>What I Learned</h3><p>This project was an excellent way to get insight into the design process of a processor. There were so many times during the creation process where I'd hit road blocks and it would dawn on me that this is exactly why the classic MIPS implementation is the way that it is. By fully implementing a processor architecture of my own design I had to account for <i>everything.</i></p><h3>What I Would Do Different</h3><p>I think the most important thing I could do differently is to absolutely abuse tools like MC Edit, which I discovered late into the project, but would have saved several hours. MC Edit gave me the ability to copy/paste areas of the map, so instead of building 8 memory locations, I only built 1 and then copy/pasted the other 7.</p><p>Something else I'd change is to make the registers more human readable. As they are, the user has to peak around certain blocks to see the register values written out as tiny binary blips.</p><p>I'm also not thrilled about the layout that the audience has in order to work with. A single cycle takes quite a while because the user has to literally travel with the bits from component to component releasing them as they go about their operations. It would be better if the user was in some kind of control tower and could witness the process in action without having to hold the bits' hand, so to speak.</p><h3>Links</h3><ul><li><a href = 'https://youtu.be/SobCXfsHwbo'>ADD Instruction Demonstration (video)</a></li><li> <a href = 'https://youtu.be/FSZAUTlHAMk'>Processor Breakdown Tour (video)</a></li></ul> At this time I do not have the source file uploaded anywhere. If you'd like a copy, shoot me an email.", type: 0, image: ['assets/mspi2.png'], imageLink: 'https://youtu.be/SobCXfsHwbo' },
		{ id: 1, title: 'Trivia Knights', author: 'Sohail', date: '1-28-2021 - 5:29pm', bodyTag: "Project Description", body: `<p>This project was made in my Software Engineering course. Myself and four other students were grouped together to simulate an agile work environment with 3 week sprints. Our mission was simply to create an app over the course of three 3-week sprints. <p>As a group we decided to create a web app using React and Django. The premise was a trivia application that people could play with their friends, kind of like trivia night at local bars. Initially we planned to do like a multiplayer hosted session sort of thing but React proved to be more challenging than we anticipated.</p> <p>We were succesful in standing up the web app however. You can see the final project results <a href = 'https://klingons-triviaknights.netlify.app'>here</a> <i>(at the time of writing this, it seems like the backend has fallen off and you cannot signup and play the game anymore. I'll be working on a fix with one of my partners soon.)</i> When the project was active, the app allowed users to sign up with a login. The user would be able to generate a quiz game which would offer random quiz questions based on the users choices. At the end of a quiz, the users score would be added to their account and users could compete for top place on the leaderboard. If you'd like to see a demo of these features, our sprint 3 demo can be seen <a href='https://youtu.be/oGzwQGoq2EE?t=650'>here.</a></p> <p>Most of my work went into the game design and UX. I'm quite proud of how it turned out. The entire presentation was pretty clean for first React project; the buttons respond clearly, it's easy to read whats going on, all the form features work as intended. If we'd had more time this could have been a pretty sweet little number.</p><h3>The Game</h3><p>Much of the game is what you might expect from a quiz app, with just a few changes. Questions had rated difficulties which would determing their point value: easy - 100, medium - 500, hard - 1000. Also, because this wasn't multiplayer, there had to be some way of rewarding a player for answering fast. So we implemented a countdown timer that would scale the users point reward down the longer they took to answer. All in all, I think we did a really good job presenting a game that could differentiate between a good score and a great score, making it fun for competitive people.</p><h3>Feature Creep - What if we'd had more time?</h3><p></p>Well just as the project started to take off the semester ended and all the plans we had for it turned to smoke, but we had some pretty cool ideas of where to go next I think:<ul><li>One of the biggest features we never got a chance to implement was to have multiplayer rooms, where each person gets asked the question at the same time, and users have scoreboards at the end. This was much more in line with the original vision of the webapp, where it was just something to play with your friends. Like actually with them, not just playing the same trivia app but separately.</li><li>We also thought it would be cool if a person playing single player could be challenged. Like, say you complete a quiz, maybe your buddy could take the same quiz and challenge your score. This was a workaround concept since we realized kind of early on that we were not going to be able to implement multiplayer in the time we had, but we were fairly close to getting this idea out the door.</li> <li>User created quizes. I thought it would be a cool feature if people could make up their own quizes to test their friends on whatever they wanted. Maybe the group of friends that is playing are all in a Radiohead fan club and would rather have questions about Radiohead instead of Sports or History.</li><li>The ability to play people near you. Maybe you don't got no friends and you're just out waiting for your order of giant pretzels to come out of the kitchen and you want to play some trivia. It might have been cool if you could have played with other people doing the same thing.</li></ul>Alright enough of that. I could go on for quite some time, my point in showing this was just to give an idea of what direction we were moving in with the project before if got cutoff.</p><h3>Challenges</h3><p>The biggest all-around challenge for me was learning React. There was an incredibly steep learning curve for me that actually made the project incredibly difficult to approach initially. If you're unfamiliar, React or ReactJS is a javascript library that is implemented in javascript but has its own syntax. I was not very good at js at the start of this project, so learning them both at the same time while keeping them separate was a serious challenge. I think if I'd had a foundation, <i>any foundation</i>, in javascript I wouldn't have had nearly as much trouble getting into this project.</p><p>The second major challenge was connecting the frontend to the backend. In all seriousness, the entire frontend had no idea how to make API calls to the backend, and I suspect neither did the backend, nor did anyone have a functional understanding of how JWT authentication worked (or at least they couldn't explain it to me) so there were several times I felt like I was coding in the dark.</p><h3>What I Learned</h3><p>The most important thing I learned was how to work on a project with other people in an agile environment. Looking back, all the ZenHub, Planning Poker stuff that seemed like an extra hassle at the beginning of the course definitely set us up for success and allowed us to operate around eachother</p><p>The other important thing I learned was how to focus on delivering the 'minimum viable product'. This is technically the first game I've ever made that had some level of completion, and its because I wasn't focused on all the cool stuff I wanted in it, I was focused on meeting a baseline criteria</p><h3>What I Would Do Different</h3><p>One thing I learned about myself is that if I'm going to take on a task like learning a new language and library to complete a goal by jumping in, I should definitely do it by wading into the shallow end first. Going head first into the deep end nearly broke me. If I could go back I'd start by learning javascript and spend a week getting familiar with it before picking up Node and spend a week getting familiar with it before attempting to pick up React. I really had no idea what was going on during the initial parts of the project and I think the code suffered big time as a result.</p><p>One more thing I'd change is how I go about learning a new language. Since this project I've started paying money for access to premium courses, and its made a huge difference in how well I can take on new information. If I could go back, I'd definitely learn React through a premium course instead of trying to learn it by gleaning scraps of info from various sources with 15+ tabs open in my browser.</p><h3>Links</h3><ul><li><a href='https://klingons-triviaknights.netlify.app'>The finished project</a></li><li><a href='https://youtu.be/oGzwQGoq2EE?t=650'>Sprint 3 Demo (video)</a></li><li><a href='https://github.com/CS3398-HOUNDS/Trivia-Application-'>Project Github page</a></li><ul>`, type: 0, image: ['assets/tk2.png'], imageLink: 'https://klingons-triviaknights.netlify.app' },
		{ id: 2, title: 'Network Simulator', author: 'Sohail', date: '6-7-2021 - 5:29pm', bodyTag: "Description", body: `<p>This was a simple python script done as a project in my Computer Networking course that was made to simulate the distribution cycles of DV packets in a closed network.</p><h3>What I Learned</h3><p> This exercise was meant to give the student an inside look at how and why DV packets are distributed, and I can honestly say I did better in this class having completed this project. If you're not familiar with DV packets, they are essentially lookup references that routers pass along to reveal the parts of the network that they are connected to. If A is connected to B and C, but B and C are not connected, then A would send a DV packet to each to let them know about eachother, and how to reach them. </p><p> It's a little more involved than that, as routes have to be compared and so forth but that's the basic idea. This project was mostly done from the hip and it paid off in this instance, because the solution was implemented quickly and correctly. </p><h3>What I Would Do Differently</h3><p> The more I do these writeups the more I realize that answering this section is probably the most telling as far as the 'worth' of the project. In this exercise the most important thing I picked up was how to shotgun a solution using python, which is not invaluable. What would I do differently? I don't think I would do anything differently, so perhaps I didn't learn as much as I should have with this project. To put that another way, as a coder I am unchanged by this experience because I'd execute it the same way if given the opportunity to do it again. </p><p>So, perhaps in the future when working on these projects I will treat them as opportunities to adapt, and maybe that is really what I will do differently.</p><h3>Links</h3><ul><li><a href='https://github.com/turbophysics/networking/blob/master/netsim.py'>See the code on Github</li></ul>`, type: 1, image: ['assets/dv.png'], imageLink: 'https://github.com/turbophysics/project-examples/blob/master/comp%20network/netsim.py' },
		{ id: 3, title: 'Game of Life', author: 'Sohail', date: '6-7-2021 - 5:29pm', bodyTag: "Old School", body: `<p>This is a C++ implementation of <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway's Game of Life</a> that I did in my foundations class with Dr. Oleg Komogortsev.</p><h3>What I Learned</h3><p> This was an difficult assignment because we were not given an example of what the finished project should look like, and the assignment write up was kind of difficult to interpret. I had never seen Conway's Game of Life before so I was very much coding in the dark. </p><p> In the end, this was an excellent exercise in algorithms, as each iteration had to check every cell in the map and determine what the next iterations outcome would be. </p><h3>What I Would Do Differently</h3><p> When I made this project, I tried and succeeded in making a version that animated the game of life so that you could see it play out in real time. This version, that is, the version I turned in, met the specifications of the assignment and simply returned the result of 100 iterations. This was a kind of hard lesson in keeping track of my experiments. Somehow I lost that version of the project and now it's impossible to slake my nostalgia for that animated version. </p><h3>Links</h3><ul><li><a href='https://github.com/turbophysics/project-examples/tree/master/life'>See the code on Github</li></ul>`, type: 1, image: ['assets/gol.png'], imageLink: 'https://github.com/turbophysics/project-examples/tree/master/life' },
		{ id: 4, title: 'Asteroids', author: 'Sohail', date: '6-7-2021 - 5:29pm', bodyTag: "Playing with the Classics", body: `<p>For the longest time now I've really wanted to make a twin stick shooter multiplayer customizable battleship asteroids type game. It's the sort of game I'd probably not be very good at myself but I would still really like to bring the idea to life. This project was an attempt to learn a bit about javascript functions and libraries while having fun. I didn't spend a whole lot of time on it and I'm pretty sure all the code is in a single file, but it was a fun project to play around with while learning.</p><h3>What I Learned</h3><p>Firstly, javascript is way more functional than I had previously thought. I really didn't think something like this was even possible in a browser, but with a few added libraries and the draw() function, I had made something that wasn't too far from a working game.</p><p>Second thing I learned was how <i>not</i> to approach projects like this. I kind of went into this project guns blazin', just firing from the hip and not even trying to avoid spaghetti. It wasn't long before the code became completely unmanageable. As much as I'd like to keep tinkering with this little number, I don't relish the prospect of trying to dig through my own code.</p><h3>What I Would Do Differently</h3><p>I think this project was an important lesson in the importance of planning ahead. I'm usually a hands-on sort of person, so spending a bunch of time figuring out how I'm going to distribute code and work with features and libraries isn't something intuitive to me, but after this project I think I definitely have a better understanding of why all that stuff is essential.</p><h3>Links</h3><ul><li><a href='https://turbophysics.github.io/asteroids.html'>Play the demo</a></li><li><a href='https://github.com/turbophysics/turbophysics.github.io/blob/master/asteroids.html'>See the code on Github</li></ul>`, type: 1, image: ['assets/asteroids.png'], imageLink: 'https://turbophysics.github.io/asteroids.html' },
	];

	news: PostObject[] = [
		{ id: 1, title: 'This site is being transitioned to an Angular based webapp', author: 'Sohail', date: '5-30-2021 - 12:14pm', bodyTag: '', body: "<p>The current and ongoing project until completion is to turn this website into webapp using Firebase and Angular. Features that I am trying to implement:</p> <ul> <li>User logins</li> <li>Profiles with past projects listed</li> <li>The ability to post new content through a webform</li> <li>A dynamic front page that loads the most recent and relevant projects</li> </ul> <span>Currently what you are seeing is a prototype of the end goal. Thanks for stopping by!</span>", type: 2, image: [''], imageLink: '' },
		{ id: 0, title: 'Sofolio web app has been launched!', author: 'Sohail', date: '1-30-2021 - 12:14pm', bodyTag: '', body: "<p>The very first version of this website was deployed to Firebase! It's not quite ready for many of the features I have planned, but this prototype will serve as the base until I'm able to make the functionality more robust.</p>", type: 2, image: [''], imageLink: '' },
	];

	getAll(): PostObject[] {
		return this.posts;
	}

	getPostByID(id: number): PostObject{
		const result = this.posts.filter(post => post.id === id);
		if (result.length === 0){
			this.router.navigate(['**']);
		}
		return result[0];
	}

	getTopPost() {
		let highestPost = 0;
		for (let post of this.posts) {
			if (post.id > highestPost && post.type === 0)
				highestPost = post.id;
		}
		return this.posts.find(item => {
			if (item.id === highestPost)
				return true;
			return false;
		});
	}

	getMainContent() {	//returns an array of posts that are not the top post
		let highestPost = 0
		let postsArray = this.posts.filter(post => 
			(post.type === 0))

		for (let post of postsArray) {
			if (post.id > highestPost)
				highestPost = post.id;
		}
		let index = postsArray.findIndex(post => {
			if (post.id === highestPost)
				return true;
			return false;
		})
		
		postsArray.splice(index, 1);
		return postsArray;
	}

	getHeadline() {
		let highestPost = 0;
		for (let news of this.news) {
			if (news.id > highestPost)
				highestPost = news.id;
		}
		return this.news.find(item => {
			if (item.id === highestPost)
				return true;
			return false;
		});
	}

	getNews() {
		return this.news;
	}

	getOtherPosts() {
		return this.posts.filter(post => post.type === 1)
	}

}

